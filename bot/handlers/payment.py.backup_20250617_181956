"""
Handler de pagamento do bot - Sistema completo de processamento de pagamentos
"""
import logging
from datetime import datetime, timedelta
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from telegram.constants import ParseMode

from bot.utils.database import get_db_session
from bot.utils.stripe_integration import create_checkout_session, verify_payment
from bot.utils.format_utils import format_currency
from app.models import Group, PricingPlan, Subscription, Transaction, Creator

logger = logging.getLogger(__name__)


async def start_payment(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Iniciar processo de pagamento apÃ³s seleÃ§Ã£o do plano"""
    query = update.callback_query
    await query.answer()
    
    # Extrair dados do callback
    # Formato: plan_GROUPID_PLANID
    try:
        _, group_id, plan_id = query.data.split('_')
        group_id = int(group_id)
        plan_id = int(plan_id)
    except:
        await query.edit_message_text(
            "âŒ Erro ao processar seleÃ§Ã£o. Tente novamente.",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("ğŸ  Menu", callback_data="back_to_start")
            ]])
        )
        return
    
    # Buscar informaÃ§Ãµes do grupo e plano
    with get_db_session() as session:
        group = session.query(Group).get(group_id)
        plan = session.query(PricingPlan).get(plan_id)
        
        if not group or not plan:
            await query.edit_message_text(
                "âŒ Grupo ou plano nÃ£o encontrado.",
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("ğŸ  Menu", callback_data="back_to_start")
                ]])
            )
            return
        
        # Calcular valores
        amount = float(plan.price)
        platform_fee = amount * 0.10  # 10% de taxa
        creator_amount = amount - platform_fee
        
        # Preparar dados do checkout
        checkout_data = {
            'group_id': group_id,
            'plan_id': plan_id,
            'amount': amount,
            'platform_fee': platform_fee,
            'creator_amount': creator_amount,
            'duration_days': plan.duration_days,
            'group_name': group.name,
            'plan_name': plan.name
        }
        
        # Salvar no contexto
        context.user_data['checkout'] = checkout_data
        
        # Mostrar resumo do pedido
        text = f"""
ğŸ’³ **RESUMO DO PEDIDO**

ğŸ“± **Grupo:** {group.name}
ğŸ“… **Plano:** {plan.name}
â± **DuraÃ§Ã£o:** {plan.duration_days} dias

ğŸ’° **Valor:** {format_currency(amount)}
ğŸ“Š **Taxa da plataforma:** {format_currency(platform_fee)}
ğŸ‘¤ **Criador recebe:** {format_currency(creator_amount)}

Escolha a forma de pagamento:
"""
        
        keyboard = [
            [
                InlineKeyboardButton("ğŸ’³ CartÃ£o (Stripe)", callback_data="pay_stripe"),
                InlineKeyboardButton("ğŸ“± PIX", callback_data="pay_pix")
            ],
            [
                InlineKeyboardButton("âŒ Cancelar", callback_data=f"group_{group_id}")
            ]
        ]
        
        await query.edit_message_text(
            text,
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=InlineKeyboardMarkup(keyboard)
        )


async def handle_payment_method(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Processar seleÃ§Ã£o do mÃ©todo de pagamento"""
    query = update.callback_query
    await query.answer()
    
    # Verificar se temos os dados do checkout
    checkout_data = context.user_data.get('checkout')
    if not checkout_data:
        await query.edit_message_text(
            "âŒ SessÃ£o expirada. Por favor, inicie novamente.",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("ğŸ  Menu", callback_data="back_to_start")
            ]])
        )
        return
    
    if query.data == "pay_stripe":
        await process_stripe_payment(query, context, checkout_data)
    elif query.data == "pay_pix":
        await query.edit_message_text(
            "ğŸ“± PIX em breve! Por enquanto, use cartÃ£o de crÃ©dito.",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("â¬…ï¸ Voltar", callback_data=f"plan_{checkout_data['group_id']}_{checkout_data['plan_id']}")
            ]])
        )


async def process_stripe_payment(query, context, checkout_data):
    """Processar pagamento via Stripe - VERSÃƒO CORRIGIDA"""
    user = query.from_user
    
    # URLs de retorno
    bot_username = context.bot.username
    success_url = f"https://t.me/{bot_username}?start=payment_success"
    cancel_url = f"https://t.me/{bot_username}?start=payment_cancel"
    
    # Criar sessÃ£o no Stripe
    result = await create_checkout_session(
        amount=checkout_data['amount'],
        group_name=checkout_data['group_name'],
        plan_name=checkout_data['plan_name'],
        user_id=str(user.id),
        success_url=success_url,
        cancel_url=cancel_url
    )
    
    if result['success']:
        # Salvar dados do checkout
        context.user_data['stripe_session_id'] = result['session_id']
        
        with get_db_session() as session:
            # Criar subscription como pending
            new_subscription = Subscription(
                group_id=checkout_data['group_id'],
                plan_id=checkout_data['plan_id'],
                telegram_user_id=str(user.id),
                telegram_username=user.username,
                status='pending',
                start_date=datetime.utcnow(),
                end_date=datetime.utcnow() + timedelta(days=checkout_data['duration_days'])
            )
            session.add(new_subscription)
            session.flush()
            
            # Criar transaction com o session_id
            transaction = Transaction(
                subscription_id=new_subscription.id,
                amount=checkout_data['amount'],
                fee=checkout_data['platform_fee'],
                net_amount=checkout_data['creator_amount'],
                payment_method='stripe',
                stripe_session_id=result['session_id'],  # â† CORRETO
                stripe_payment_intent_id=None,  # â† Deixar None por enquanto
                status='pending'
            )
            session.add(transaction)
            session.commit()
            
            logger.info(f"Criada subscription {new_subscription.id} e transaction com session_id: {result['session_id']}")
        
        # Mostrar instruÃ§Ãµes e botÃ£o de pagamento
        text = """
ğŸ” **Pagamento Seguro via Stripe**

Clique no botÃ£o abaixo para ser redirecionado para a pÃ¡gina de pagamento segura do Stripe.

ğŸ’³ **Aceita:** CartÃµes de crÃ©dito e dÃ©bito

ApÃ³s concluir o pagamento:
1. VocÃª serÃ¡ redirecionado de volta ao Telegram
2. Clique em "Verificar Pagamento" para confirmar
3. SerÃ¡ adicionado ao grupo automaticamente

âš ï¸ **Importante:** NÃ£o feche esta conversa durante o pagamento!
"""
        
        keyboard = [
            [InlineKeyboardButton("ğŸ’³ Pagar Agora", url=result['url'])],
            [InlineKeyboardButton("ğŸ”„ Verificar Pagamento", callback_data="check_payment_status")],
            [InlineKeyboardButton("âŒ Cancelar", callback_data=f"group_{checkout_data['group_id']}")]
        ]
        
        await query.edit_message_text(
            text,
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    else:
        # Erro ao criar sessÃ£o
        await query.edit_message_text(
            f"âŒ Erro ao processar pagamento: {result.get('error', 'Erro desconhecido')}\n\n"
            "Por favor, tente novamente ou entre em contato com o suporte.",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("ğŸ”„ Tentar Novamente", callback_data=f"plan_{checkout_data['group_id']}_{checkout_data['plan_id']}"),
                InlineKeyboardButton("ğŸ“ Suporte", url="https://t.me/suporte_televip")
            ]])
        )


async def handle_payment_success(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler para quando usuÃ¡rio retorna do pagamento com sucesso"""
    user = update.effective_user
    
    logger.info(f"UsuÃ¡rio {user.id} retornou do pagamento")
    
    # Mensagem de boas-vindas
    text = """
âœ… **Obrigado pelo seu pagamento!**

Estamos processando sua transaÃ§Ã£o. Isso pode levar alguns segundos.

Clique no botÃ£o abaixo para verificar o status:
"""
    
    keyboard = [[
        InlineKeyboardButton("ğŸ”„ Verificar Status", callback_data="check_payment_status"),
        InlineKeyboardButton("ğŸ  Menu Principal", callback_data="back_to_start")
    ]]
    
    await update.message.reply_text(
        text,
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=InlineKeyboardMarkup(keyboard)
    )


async def handle_payment_cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler para quando usuÃ¡rio cancela o pagamento"""
    user = update.effective_user
    
    logger.info(f"UsuÃ¡rio {user.id} cancelou o pagamento")
    
    text = """
âŒ **Pagamento Cancelado**

VocÃª cancelou o processo de pagamento. 

Se mudou de ideia, vocÃª pode tentar novamente a qualquer momento.
"""
    
    keyboard = [[
        InlineKeyboardButton("ğŸ” Ver Grupos", callback_data="discover"),
        InlineKeyboardButton("ğŸ  Menu Principal", callback_data="back_to_start")
    ]]
    
    await update.message.reply_text(
        text,
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=InlineKeyboardMarkup(keyboard)
    )


async def list_user_subscriptions(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Listar assinaturas ativas do usuÃ¡rio"""
    query = update.callback_query
    if query:
        await query.answer()
        user = query.from_user
        message = query
    else:
        user = update.effective_user
        message = update
    
    with get_db_session() as session:
        # Buscar assinaturas ativas
        subscriptions = session.query(Subscription).filter(
            Subscription.telegram_user_id == str(user.id),
            Subscription.status == 'active',
            Subscription.end_date > datetime.utcnow()
        ).all()
        
        if not subscriptions:
            text = """
ğŸ“­ **VocÃª nÃ£o tem assinaturas ativas**

Explore nossos grupos exclusivos e comece sua jornada!
"""
            keyboard = [[
                InlineKeyboardButton("ğŸ” Descobrir Grupos", callback_data="discover"),
                InlineKeyboardButton("ğŸ  Menu", callback_data="back_to_start")
            ]]
        else:
            text = "ğŸ“± **SUAS ASSINATURAS ATIVAS**\n\n"
            
            for sub in subscriptions:
                group = sub.group
                days_left = (sub.end_date - datetime.utcnow()).days
                
                text += f"""
ğŸ“Œ **{group.name}**
â± Expira em: {days_left} dias ({sub.end_date.strftime('%d/%m/%Y')})
ğŸ’° Plano: {sub.plan.name}

"""
            
            keyboard = [
                [InlineKeyboardButton("ğŸ” Descobrir Mais Grupos", callback_data="discover")],
                [InlineKeyboardButton("ğŸ  Menu", callback_data="back_to_start")]
            ]
        
        if hasattr(message, 'edit_message_text'):
            await message.edit_message_text(
                text,
                parse_mode=ParseMode.MARKDOWN,
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
        else:
            await message.reply_text(
                text,
                parse_mode=ParseMode.MARKDOWN,
                reply_markup=InlineKeyboardMarkup(keyboard)
            )


# Registrar handlers
def register_payment_handlers(application):
    """Registrar todos os handlers de pagamento"""
    from telegram.ext import CallbackQueryHandler, CommandHandler
    
    # Handlers de callback
    application.add_handler(CallbackQueryHandler(start_payment, pattern=r'^plan_\d+_\d+$'))
    application.add_handler(CallbackQueryHandler(handle_payment_method, pattern='^pay_(stripe|pix)$'))
    application.add_handler(CallbackQueryHandler(list_user_subscriptions, pattern='^my_subscriptions$'))
    
    # Command handlers
    application.add_handler(CommandHandler('subscriptions', list_user_subscriptions))
    
    logger.info("Handlers de pagamento registrados")

# FunÃ§Ãµes adicionadas automaticamente

async def handle_plan_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler para seleÃ§Ã£o de plano"""
    # Alias para start_payment
    await start_payment(update, context)

async def handle_payment_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler para callbacks de pagamento"""
    query = update.callback_query
    
    if query.data.startswith('pay_'):
        await handle_payment_method(update, context)
    elif query.data == 'check_payment_status':
        from bot.handlers.payment_verification import check_payment_status
        await check_payment_status(update, context)
