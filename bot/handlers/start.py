# bot/handlers/start.py
"""
Handler do comando /start com suporte multi-criador
VERS√ÉO CORRIGIDA - Sem refer√™ncias a plan.description
"""
import logging
from datetime import datetime, timedelta
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from telegram.constants import ParseMode

from bot.utils.database import get_db_session
from bot.keyboards.menus import get_main_menu, get_plans_menu
from app.models import Group, Creator, PricingPlan, Subscription, Transaction

logger = logging.getLogger(__name__)

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Handler do comando /start
    - Sem par√¢metros: mostra dashboard do usu√°rio
    - Com g_XXXXX: inicia fluxo de assinatura
    - Com success_: retorno de pagamento bem-sucedido
    - Com cancel: retorno de pagamento cancelado
    """
    user = update.effective_user
    args = context.args
    
    logger.info(f"Start command - User: {user.id}, Args: {args}")
    
    # Tratar diferentes tipos de argumentos
    if args:
        if args[0].startswith('success_'):
            from bot.handlers.payment import handle_payment_success
            await handle_payment_success(update, context)
            return
        elif args[0] == 'cancel':
            await handle_payment_cancel(update, context)
            return
        elif args[0].startswith('g_'):
            group_id = args[0][2:]
            logger.info(f"Iniciando fluxo de assinatura para grupo ID: {group_id}")
            await start_subscription_flow(update, context, group_id)
            return
    
    # Sem argumentos - mostrar dashboard
    await show_user_dashboard(update, context)

async def show_user_dashboard(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Mostrar dashboard com assinaturas do usu√°rio"""
    # Detectar se veio de comando ou callback
    if update.callback_query:
        user = update.callback_query.from_user
        message = update.callback_query.message
        is_callback = True
    else:
        user = update.effective_user
        message = update.message
        is_callback = False
    
    with get_db_session() as session:
        # Verificar transa√ß√µes pendentes
        if not context.user_data.get('skip_pending_check'):
            pending_transactions = session.query(Transaction).join(
                Subscription
            ).filter(
                Subscription.telegram_user_id == str(user.id),
                Transaction.status == 'pending',
                Transaction.created_at >= datetime.utcnow() - timedelta(hours=2)
            ).all()
            
            if pending_transactions:
                logger.info(f"Encontradas {len(pending_transactions)} transa√ß√µes pendentes para usu√°rio {user.id}")
                
                # Mostrar bot√£o para verificar pagamento
                text = f"""
üëã Ol√° {user.first_name}!

üîÑ **Detectamos um pagamento pendente!**

Parece que voc√™ tem um pagamento em processamento. 

üí° Se voc√™ acabou de fazer um pagamento, clique no bot√£o abaixo para verificar o status.

Se n√£o fez nenhum pagamento recentemente, pode continuar para o menu principal.
"""
                keyboard = [
                    [
                        InlineKeyboardButton("üîÑ Verificar Pagamento", callback_data="check_payment_status")
                    ],
                    [
                        InlineKeyboardButton("üè† Continuar para Menu", callback_data="continue_to_menu")
                    ]
                ]
                
                if is_callback:
                    await message.edit_text(
                        text,
                        parse_mode=ParseMode.MARKDOWN,
                        reply_markup=InlineKeyboardMarkup(keyboard)
                    )
                else:
                    await message.reply_text(
                        text,
                        parse_mode=ParseMode.MARKDOWN,
                        reply_markup=InlineKeyboardMarkup(keyboard)
                    )
                return
        
        # Buscar todas as assinaturas do usu√°rio
        subscriptions = session.query(Subscription).filter_by(
            telegram_user_id=str(user.id),
            status='active'
        ).order_by(Subscription.end_date).all()
        
        if not subscriptions:
            # Usu√°rio novo - mostrar mensagem de boas-vindas
            text = f"""
üëã Ol√° {user.first_name}!

Bem-vindo ao **TeleVIP Bot** ü§ñ

Sou seu assistente para gerenciar assinaturas de grupos VIP no Telegram.

üéØ **O que voc√™ pode fazer:**
‚Ä¢ Assinar grupos exclusivos
‚Ä¢ Gerenciar suas assinaturas
‚Ä¢ Descobrir novos conte√∫dos
‚Ä¢ Renovar com desconto

üí° **Como come√ßar:**
Use /descobrir para explorar grupos dispon√≠veis ou clique em um link de convite de um criador.

Precisa de ajuda? Use /help ou clique no bot√£o abaixo.
"""
            keyboard = [
                [
                    InlineKeyboardButton("üîç Descobrir Grupos", callback_data="discover"),
                    InlineKeyboardButton("‚ùì Ajuda", callback_data="help")
                ]
            ]
        else:
            # Usu√°rio com assinaturas - mostrar dashboard
            text = f"""
üëã Ol√° {user.first_name}!

üìä **Suas Assinaturas Ativas:** {len(subscriptions)}

"""
            # Listar assinaturas ativas
            for sub in subscriptions[:5]:  # Mostrar at√© 5
                days_left = (sub.end_date - datetime.utcnow()).days
                status_emoji = "üü¢" if days_left > 7 else "üü°" if days_left > 3 else "üî¥"
                
                # Verificar se group existe antes de acessar
                if sub.group:
                    text += f"{status_emoji} **{sub.group.name}**\n"
                    text += f"   Plano: {sub.plan.name if sub.plan else 'N/A'}\n"
                    text += f"   Expira em: {days_left} dias\n\n"
            
            if len(subscriptions) > 5:
                text += f"... e mais {len(subscriptions) - 5} assinaturas\n\n"
            
            text += "Use /status para ver detalhes completos."
            
            keyboard = [
                [
                    InlineKeyboardButton("üìä Ver Todas", callback_data="check_status"),
                    InlineKeyboardButton("üîç Descobrir Mais", callback_data="discover")
                ],
                [
                    InlineKeyboardButton("‚ùì Ajuda", callback_data="help")
                ]
            ]
        
        # Enviar ou editar mensagem
        if is_callback:
            await message.edit_text(
                text,
                parse_mode=ParseMode.MARKDOWN,
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
        else:
            await message.reply_text(
                text,
                parse_mode=ParseMode.MARKDOWN,
                reply_markup=InlineKeyboardMarkup(keyboard)
            )

async def start_subscription_flow(update: Update, context: ContextTypes.DEFAULT_TYPE, group_id: str):
    """Iniciar fluxo de assinatura para um grupo espec√≠fico"""
    user = update.effective_user
    
    try:
        group_id = int(group_id)
    except ValueError:
        logger.error(f"ID de grupo inv√°lido: {group_id}")
        await update.message.reply_text("‚ùå Link inv√°lido.")
        return
    
    with get_db_session() as session:
        # Buscar grupo pelo ID do banco de dados
        group = session.query(Group).filter_by(id=group_id).first()
        
        if not group:
            logger.warning(f"Grupo n√£o encontrado - ID: {group_id}")
            
            # Listar grupos dispon√≠veis para debug
            all_groups = session.query(Group).all()
            logger.info(f"Grupos no banco: {[(g.id, g.name) for g in all_groups]}")
            
            await update.message.reply_text(
                "‚ùå Grupo n√£o encontrado.\n\n"
                "Poss√≠veis causas:\n"
                "‚Ä¢ Link expirado ou inv√°lido\n"
                "‚Ä¢ Grupo foi removido\n\n"
                "Use /descobrir para ver grupos dispon√≠veis."
            )
            return
            
        if not group.is_active:
            logger.warning(f"Grupo inativo: {group.name} (ID: {group_id})")
            await update.message.reply_text(
                "‚ùå Este grupo est√° temporariamente indispon√≠vel.\n\n"
                "Entre em contato com o criador ou use /descobrir para ver outros grupos."
            )
            return
        
        # Log para debug
        logger.info(f"Grupo encontrado: {group.name} (ID: {group.id}, Ativo: {group.is_active})")
        
        # Verificar se j√° tem assinatura ativa
        existing_sub = session.query(Subscription).filter_by(
            group_id=group_id,
            telegram_user_id=str(user.id),
            status='active'
        ).first()
        
        if existing_sub:
            days_left = (existing_sub.end_date - datetime.utcnow()).days
            text = f"""
‚úÖ **Voc√™ j√° √© assinante!**

**Grupo:** {group.name}
**Plano atual:** {existing_sub.plan.name if existing_sub.plan else 'N/A'}
**Dias restantes:** {days_left}

Sua assinatura expira em: {existing_sub.end_date.strftime('%d/%m/%Y')}
"""
            keyboard = [
                [
                    InlineKeyboardButton("üìä Ver Status", callback_data="check_status"),
                    InlineKeyboardButton("üè† Menu Principal", callback_data="back_to_start")
                ]
            ]
            
            await update.message.reply_text(
                text,
                parse_mode=ParseMode.MARKDOWN,
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
            return
        
        # Buscar planos dispon√≠veis
        plans = session.query(PricingPlan).filter_by(
            group_id=group_id,
            is_active=True
        ).order_by(PricingPlan.price).all()
        
        if not plans:
            logger.warning(f"Nenhum plano ativo para o grupo {group.name}")
            await update.message.reply_text(
                "‚ùå Nenhum plano dispon√≠vel para este grupo no momento.\n\n"
                "Entre em contato com o administrador do grupo."
            )
            return
        
        # Mostrar informa√ß√µes do grupo e planos
        creator = group.creator
        text = f"""
üéØ **{group.name}**

üë§ **Criador:** {creator.name if creator else 'N/A'}
üìù **Descri√ß√£o:** {group.description or 'Grupo VIP exclusivo'}
üë• **Assinantes:** {group.total_subscribers or 0}

üíé **Planos dispon√≠veis:**
"""
        
        keyboard = []
        for plan in plans:
            text += f"\nüìå **{plan.name}** - R$ {plan.price:.2f}"
            text += f"\n   ‚è± {plan.duration_days} dias\n"
            
            keyboard.append([
                InlineKeyboardButton(
                    f"üí≥ {plan.name} - R$ {plan.price:.2f}",
                    callback_data=f"plan_{group_id}_{plan.id}"
                )
            ])
        
        keyboard.append([
            InlineKeyboardButton("‚ùå Cancelar", callback_data="cancel")
        ])
        
        await update.message.reply_text(
            text,
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando de ajuda"""
    help_text = """
üìã **Central de Ajuda TeleVIP**

**üî∏ Comandos Dispon√≠veis:**

/start - Menu principal e suas assinaturas
/status - Detalhes de todas suas assinaturas
/descobrir - Explorar grupos dispon√≠veis
/help - Esta mensagem de ajuda

**‚ùì Perguntas Frequentes:**

**Como assino um grupo?**
Clique no link fornecido pelo criador ou use /descobrir

**Como cancelo uma assinatura?**
As assinaturas n√£o renovam automaticamente

**Posso mudar de plano?**
Sim, quando sua assinatura atual expirar

**√â seguro?**
Sim, usamos Stripe para processar pagamentos

**üìû Suporte:**
‚Ä¢ Problemas com pagamento: @suporte_televip
‚Ä¢ D√∫vidas sobre conte√∫do: contate o criador do grupo

üîí Seus dados est√£o seguros e protegidos.
"""
    
    await update.message.reply_text(
        help_text,
        parse_mode=ParseMode.MARKDOWN
    )

async def handle_payment_cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler para pagamento cancelado"""
    text = """
‚ùå **Pagamento Cancelado**

Seu pagamento foi cancelado e nenhuma cobran√ßa foi realizada.

Se mudou de ideia, voc√™ pode:
‚Ä¢ Usar o link original do grupo
‚Ä¢ Explorar outros grupos com /descobrir
‚Ä¢ Ver suas assinaturas atuais com /start

Precisando de ajuda? Use /help
"""
    
    keyboard = [
        [
            InlineKeyboardButton("üîç Descobrir Grupos", callback_data="discover"),
            InlineKeyboardButton("‚ùì Ajuda", callback_data="help")
        ]
    ]
    
    await update.message.reply_text(
        text,
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=InlineKeyboardMarkup(keyboard)
    )